// int can_have_more_children(struct task_struct *t) {
//     return t->number_of_children < MAX_CHILDREN;
// }
//
// void init_children(struct task_struct *t) {
//     t->number_of_children = 0;
//
//     for (int i = 0; i < MAX_CHILDREN; ++i) {
//         t->children[i] = NULL;
//     }
// }
//
// int add_child(struct task_struct *parent, struct task_struct *child) {
//     for (int i = 0; i < MAX_CHILDREN; ++i) {
//         if (parent->children[i] != NULL) continue;
//
//         parent->children[i] = child;
//         parent->number_of_children++;
//         return 1;
//     }
//
//     return -1;
// }

sys_wait() {
    // if (current()->number_of_children == 0) return ECHILD;
    //
    // int child_pid = -1;
    // // int child_exit_status = -1; // idk donde meter esto
    //
    // for (int i = 0; i < MAX_CHILDREN; ++i) {
    //     if (current()->children[i] == NULL) continue;
    //
    //     struct task_struct *child = current()->children[i];
    //
    //     child_pid = child->PID;
    //     // child_exit_status = child->exit_status;
    //     update_process_state_rr(child, &freequeue);
    //     current()->children[i] = NULL;
    //
    //     break;
    // }
    //
    // return child_pid;
}



void task_switch(union task_union*t) {
    push ebp
    ebp <- esp

    cr3 <- new->task.DIR            // cambia el tlb para poder traducir las direcciones logicas unicas al proceso
    tss.esp0 <- new->stack[1024]    // pone la nueva pila de sistema (1024 para invalidar todo lo que habia antes).

    // esto no se puede hacer en c, hay que llamar a una función en assembly.
    ebp = current()->task.kernel_esp
    // para este man lo mismo que el de arriba.
    esp <- new->task.kernel_esp

    pop ebp
    ret
}

    |                       |
    |       ebp             |
    |-----------------------|
    |   @ret (a lo que      |
    |   llamo el switch)    |
    |-----------------------|
    |   new (argumento      |
    |   de task_switch)     |
    |-----------------------|
    |   mierda varia de     |
    |   la rutina de sistema|
    |-----------------------|
    |       ebp             |
    |-----------------------|
    |   @ret a usuario      |
    |   (salir de handler)  |
    |-----------------------|
    |       CTX SW          |
    |-----------------------|
    |       CTX HW          |
    |_______________________|

    pthread_create(void *(*func)(void*), void *param)
        - inicializar task_union (copiando del padre). como se copian tal cual, sabemos que pertenecen al mismo proceso.
        - inicializar el stack de usuario.
        - inicializar el stack de sistema.
            - tocar el EIP y CS del contexto HW para que apunte a func (primer parametro de phtread_create()).
            - tocar el ESP del contexto HW para que apunte al tope de la nueva pila de usuario.


    - para poder hacer que el thread salga bien si el código de usuario no pone el pthread_exit() se hace lo siguiente:
        - se crea un wrapper que ejecute la función de usuario, y luego se ejecuta el phtread_exit().
        void* pthread_wrapper(void *(*func)(void*), void *param) {
            func(void*);
            pthread_exit();
        }

        - la función usuario entonces será:
            |-----------------------|
            |           0           |
            |-----------------------|
            |     &func usuario     |
            |-----------------------|
            |       *params         |
            |_______________________|

    ------------------------
    - el task_switch:
        - si veo que veo a cambiar al mismo proceso (otro thread) no hace falta tocar el cr3.
        - así se evita flushear el TLB y tener mucho TLB misses.
            - básicamente es un if antes del set_cr3()

 - sys_fork()
  - primero comprobacion de que tengo los recursos necesarios:
  - si alguno falla, los de arriba se liberan:

    - asignar un task struct al nuevo proceso.
    - asignar una Page Table (DIR) 
    - asignar memoria fisica.

  - ahora se empieza el trabajo en si:

    - init task_union del hijo -> copiar el del padre al hijo.
    - copiar memoria del padre al hijo (tocho):
        - el contenido de kernel del PCB son iguales entre ellos. No se copian, el TLB referencia el del padre.

    - asignar pid
    - preparar contexto de ejecución del hijo
    - poner task_struct del hijo en readyqueue

    |-----------------------|
    |   mierda varia de     |
    |   la rutina de sistema|
    |-----------------------|
    |       ebp             |
    |-----------------------|
    |   @ret a sys_fork     |
    |   (salir de handler)  |
    |-----------------------|
    |       CTX SW          |
    |-----------------------|
    |       CTX HW          |
    |-----------------------|


    - solo hijo:
        - crear función ret_from_fork() que literal solo retorne 0.

        |-----------------------|
        |           0           |
        |-----------------------|
        |    @ret_from_fork     |
        |-----------------------|
        |   @ret a sys_fork     |
        |   (salir de handler)  |
        |-----------------------|
        |       CTX SW          |
        |-----------------------|
        |       CTX HW          |
        |-----------------------|

        - el task_switch() al final hace:
            pop ebp
            ret
        - al hacer pop ebp, ebp ahora vale 0.
        - al hacer ret va a @ret_from_fork (esp ahora apunta a @ret_sys_fork), y hace lo siguiente:
            push de ebp (ebp aqui vale 0)
            ebp <- esp (ebp ahora vale esp, y apunta al tope del stack, donde esta el 0 que acabamos de pushear)
            eax <- 0
            pop ebp (ebp ahora vale 0, y esp apunta a @ret_sys_fork.
            ret
        - al hacer ret volvemos al handler de sys_fork
